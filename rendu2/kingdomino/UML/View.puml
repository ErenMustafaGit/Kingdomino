@startuml
'skinparam style strictuml
skinparam style strictuml
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods
skinparam BackgroundColor HoneyDew

'class main qui va executer le jeu
class KingDomino{
+main()
}


package Controller{
'package CONTROLLER
package GameController #technology{
    ' plateau de jeu
    class GameController{
        -game: GameContext
        +GameController(game:GameContext)
        +initializeGame((nbPlayers:Integer,colors: KingColor[], gameMode:Integer)
        +placeCastle(player:Player, pos_x :Integer, pos_y :Integer
        +placeTile(x:Integer, y:Integer)
        +skipTurn()
        +pickTiles()
        +chooseTile(tile:Tile)
        +rotate()
        +reverse()
        +destroyGame()
    }
}

}


package Model #mistyrose{
    'interface players
    interface PlayerStrategy <<Interface>>{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
    }
    class TwoPlayers implements PlayerStrategy{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
    }

    class ThreePlayers implements PlayerStrategy{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
    }

   class FourPlayers implements PlayerStrategy{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
   }



    class Deck{
        -tiles:Tile[]
        +Deck()
        +Deck(deckSize:Integer)
        +getTile():Tile
        +getNbTiles(): Integer
    }


    'tuiles numéroté
    class Tile {
        -number:Integer
        -left : Ground
        -right : Ground
        -direction:Direction
        +Tile(number: integer)
        +Tile(number: Integer, left:Ground, right : Ground)
        +getLeft():Ground
        +setLeft(left:Ground)
        +getRight():Ground
        +setRight(right: Ground)
        +getNumber():Integer
        +setNumber(number:Integer)
        +rotate()
        +reverse()
        +getDirection():Direction
        +compareTo(o: Tile): Integer

    }
    'coté de la tuile (droite ou gauche)
    class Ground{
        -color: GroundColor
        -crownNumber:Integer
        -groundCounted:Boolean
        -crownCounted:Boolean
        +Ground(color:GroundColor, crownNumber:Integer)
        +isGroundCounted():Boolean
        +isCrownCounted():Boolean
        +setGroundCounted(groundCounted:Boolean)
        +setCrownCounted(crownCounted:Boolean)
        +getCrownNumber():Integer
        +getColor():GroundColor
        +setCrownNumber(crownNumber:Integer)
    }
    'couleur des cotés de la tuile
    enum GroundColor{
    -GREY
    -BLUE
    -DARKGREEN
    -BLACK
    -BROWN
    -YELLOW
    -LIGHTGREEN
    +{static}+getColor(String:color):GroundColor
    }
    'strategy permettant de pouvoir choisir le jeu qu'on veut
    interface GameMode <<Interface>>{
        +calculateScore(p:PlayerBoard)
        getnamegame(): String
        +isHarmony(p:PlayerBoard):Boolean
        +isKingdomMiddle(p:PlayerBoard):Boolean
    }
    'contexte du jeu
    class GameContext{
        -nbPlayersStrat:PlayerStrategy
        -gameMode: GameMode
        -deck:Deck
        -currentTiles:Tile[]
        -observers : GameObserver[][]
        -players : Player[]
        -kings:King[]
        -nextRoundKings:King[]
        -turn : Integer

        +GameContext()
        +destroy()
        +getCurrentTiles(): King[]
        +addObserver(gameObserver:GameObserver)
        +setPlayerStrategy(nbPlayers:Integer)
        +getGameMode():GameMode
        +getNbPlayersStrat(): PlayerStrategy
        +setGameStrategy(gameModeChoosen: Integer)
        +initGame(colors: KingColor[])
        +getPlayers():Player[]

        -createDeck()
        -createKing(color:KingColor, number:Integer, player:Player)
        -createPlayers(colors:KingColor[])

        +getPlayerCastleTurn():Player
        +getKingTurn():King
        +getTurn(): Integer
        +pickTiles()
        +setCastle(player:Player, x: Integer, y: Integer): Boolean
        +setTile(x: Integer, y: Integer)
        +allTilesChoosen(): Boolean
        +chooseTile(tile:Tile)
        +orderNextRoundKings()
        +rotateCurrentTile()
        +reverseCurrentTile()
        +skipTurn()
        +getPlayersRank(Player[])
        +notifyObservers()
        +notifyObserversEnd()
    }

    package GameModes{

            class NormalMode {
                +calculateScore(p:PlayerBoard): Integer
                +countcell(p: PlayerBoard, x: Integer, y: Integer):Integer
                +print(p:PlayerBoard)
                +coutcrown(p:PlayerBoard, x: Integer, y: Integer): Integer
                +getnamegame():String
                +isHarmony(p:PlayerBoard): Boolean
                +isKingdomMiddle(p:PlayerBoard):Boolean
            }
            abstract class ModeDecorator{
                -wrappee:GameMode
                +ModeDecorator(gameMode:GameMode)
                +calculateScore(p:Player):Integer
                +isKingdomMiddle(p:PlayerBoard):Boolean
                +isHarmony(p:PlayerBoard):Boolean
            }

            class MiddleKingdom extends ModeDecorator {
                +MiddleKingdom(gameMode:GameMode)
                +calculateScore(p:PlayerBoard):Integer
                -calculateKingdomBonus(p:PlayerBoard): Integer
                +isKingdomMiddle(p:PlayerBoard):Boolean
                +getnamegame():String
                +isHarmony(p:PlayerBoard):Boolean
            }

            'class harmonie
            class Harmony extends ModeDecorator {
            +Harmony(gameMode:GameMode)
            +calculateScore(p:PlayerBoard):Integer
            -calculateHarmonyBonus(p:PlayerBoard): Integer
            +isHarmony(p:PlayerBoard):Boolean
            +getnamegame():String
            +isKingdomMiddle(p:PlayerBoard):Boolean
            }
    }
    'interface observer qui va permettre de notifier les changements
    interface GameObserver <<Interface>>{
        +update(game:GameContext)
        +updateEnd(gameContext:GameContext)
    }



    class PlayerBoard{
        +BOARD_SIZE:Integer = 5
        -board: Positionnable[]
        +PlayerBoard()

        +PlayerBoard(castle:Castle)
        +setCastle(x: Integer, y: Integer, castle: Castle) : Boolean
        +setTile(x:Integer, y:Integer, dir:Direction, tile:Tile): Boolean
        +getRightXY(x:Integer, y:Integer, dir:Direction): Integer[]
        +isPosable(x:Integer, y:Integer):Boolean
        +ispPlayable(tile:Tile):Boolean
        +isSameGround(x:Integer, y:Integer, ground:Ground):Boolean
        +getPositionnable(x: Integer, y: Integer): Positionnable
        +getBoard():Positionnable[]
        +getBOARD_SIZE(): Integer
    }
    interface Positionnable <<Interface>>{
        +getColor():GroundColor
        +getCrownNumber(): Integer
        +isGroundCounted(): Boolean
        +isCrownCounted():Boolean
        +setGroundCounted(groundCounted:Boolean)
        +setCrownCounted(crownCounted:Boolean)
    }

    enum Direction{
        NORTH
        SOUTH
        EAST
        WEST
    }

    'joueur
    class Player{
        -playerColor: KingColor
        -board: PlayerBoard

        +Player(color:KingColor,board:PlayerBoard)
        +getPlayerColor(): KingColor
        +setPlayerColor(playerColor:KingColor)
        +getBoard(): PlayerBoard
        +setBoard(board:PlayerBoard)

    }

    'roi
    class King{
        -color: KingColor
        -player: Player
        -choosenTile:Collection<Tile>
        +King(color:KingColor, player:Player)
        +getColor(): KingColor
        +setChoosenTile(tile:Tile)
        +removeTile()
        +getTile():Tile
        +getPlayer():Player
    }
    'class chateau
    class Castle{
        +getColor():GroundColor
        +getCrownNumber(): Integer
        +isGroundCounted():Boolean
        +isCrownCounted():Boolean
        +setGroundCounted()
        +setCrownCounted()

    }

    'couleur du roi et du chateau
    enum KingColor{
    +PINK
    +BLUE
    +GREEN
    +YELLOW
    {static}+getColor(color:KingColor):Color
    }
    package Utilities{
        class CSVReader{
            {static} - RESSOURCE_PATH = "./kingdomino/ressources/"
            {static} read(filename:String):Collection<Collection<String>>
        }

        class IMGReader{
            {static} - RESSOURCE_PATH = "./kingdomino/ressources/"
            {static} getImagePnl(String:filename):JLabel
            {static} getImage(String:filename):Image
        }
        class FontReader{
            {static} - instance : FontReader
            -algerian : Font
            -showcard : Font
            -bookmanold : Font
            - symbola : Font

            +getAlgerian(): Font
            +getShowcard(): Font
            +getBookmanold(): Font
            +getSymbola(): Font
        }
    }
}

'package VIEW
package view #D0E1D4{
    'application du jeu (design avec Swing)
    class MyWindow implements GameObserver{
        -gameController: GameController
        -game: GameContext
        -gameView: GameView

        +MyWindow(gameController: GameController, game: GameContext)
        +getGame(): GameContext
        +getGameController(): GameController
        +setGamePanel()
        +setChoosingMenu()
        +setMainMenu

        +update(gameContext:GameContext)
        +updateEnd(gameContext:GameContext)
    }

    class MainMenu{
        -mainFrame: MyWindow
        -img: ImageIcon
        -btnColor : Color
        -btnHoverColor: Color

        +MainMenu(MyWindow: MyWindow)
        +paint(g: Graphics)
    }

    class ChoosingMenu{
         -btnColor : Color
         -btnHoverColor: Color
         -cboColor: Color
         - img: ImageIcon

         +ChoosingMenu(MyWindow: MyWindow)
         +getMainPanel():JPanel
         +paint(g: Graphics)
         -createColorCbo()
         -isDifferentColor():Boolean

        }

    class GameView{
        -mainFrame: MyWindow
        - IMG_SIZE : Integer = 60
        -img: ImageIcon
        -imgBoard : ImageIcon
        -boardsPanel: JPanel
        - gameInterac : JPanel
        -headerLbl: MyLabel
        -tourLbl : MyLabel
        -btnColor: Color
        - btnHoverColor: Color
        -errorMessageLbl: MyLabel
        -crownString: String

        +GameView(MyWindow:MyWindow)
        +getMainPanel():JPanel
        +createPlayerBoardPanel(player: Player, enable: Boolean): JPanel
        +createChoosenTile(tile: Tile, king: King)
        +createTile(tile: Tile, king : King): JPanel
        +createCastle: JButton
        +updateInteractionBoard()
        +updatePlayersBoards()
        +update(game: GameContext)
        +paint(g: Graphics)
        }

    class EndView{
        -mainFrame : MyWindow
        -img : ImageIcon

        +EndView(MyWindow: MyWindow)
        +paint(g: Graphics)

    }
    class Log implements GameObserver{
        +update(gameContext:GameContext)
        +updateEnd(gameContext:GameContext)
    }
    package Components{
        class MyLabel{
        {static}+EFFECT_PLAIN: Integer=0
        {static}+EFFECT_GRADIENT: Integer=1
        {static}+EFFECT_IMAGE: Integer=2
        {static}+EFFECT_IMAGE_ANIMATION: Integer=3
        {static}+EFFECT_COLOR_ANIMATION: Integer=4
        #effect_index/ Integer= EFFECT_PLAIN
        #shearFactor: Double = 0.0
        #outlineColor: Color
        #stroke: Stroke
        #gradient : GradientPaint
        #foregroundImage : Image
        #animator : Thread
        #isRunning: Boolean = false
        #m_delay: Integer
        #m_xShift: Integer

        +MyLabel()
        +MyLabel(text: String)
        +MyLabel(text: String, alignment: Integer)
        +setEffectIndex(e: Integer)
        +getEffectIndex(): Integer
        +setShearFactor(s: Double)
        +getShearFactor(): Double
        +setOutlineColor(c: Color)
        +getOutlineColor(): Color
        +setStroke(s: Stroke)
        +getStroke():Stroke
        +setGradient(g: GradientPaint)
        +getGradient(): GradientPaint
        +setForegroundImage(img: Image)
        +getForegroundImage(): Image
        +startAnimation(delay: Integer)
        +stopAnimation()
        +paintComponent(g:Graphics)
        +fillByImage(g2: Graphics2D, shape: Shape, xOffset: Integer)

        'liaison avec GameView
        'ChoosingMenu
        }
    }


}




Ground ..|> Positionnable
Castle ..|> Positionnable
PlayerBoard o-> "* \n -board"  Positionnable : > contains

Deck ..> CSVReader :  > use
Ground "1\n-color"*-->"1"GroundColor
Tile *-->Ground : "1\n-left\n1\n-right" > composed

'A SUPP
Deck "..* -tiles" *-> Tile : > had




GameContext "..4\n-currentTiles" o--> Tile
GameContext "1\n-deck" *-r-> Deck
GameContext *--> GameMode  : "1\n-gameMode" > select
GameContext *--> PlayerStrategy : "1\n-playerStrategy" > select
GameContext *-> Player : "2..4\n-players" > played by


'BoardGame  *-> Player : "2..4\n-players" > played by
GameController o--> GameContext : "1\n-gameContext" > had


Player *-> PlayerBoard : "1\n-board" > had
Player  o--> King : "1..2\n-playerKings" > had

PlayerBoard .> Direction : > use


'Implements de GameMode
'Harmony .u.|> GameMode
'MiddleKingdom .u.|> GameMode
ModeDecorator .u.|> GameMode
NormalMode .u.|> GameMode

King"1\n-color"*-->"1" KingColor: > had


Castle"1\n-color"*-->GroundColor : > had

MyWindow "1\n-mainMenu" *--> MainMenu
MyWindow "1\n-choosingMenu" *--> ChoosingMenu
MyWindow "1\n-gameView" *--> GameView
MyWindow "1\n-endView" *---> EndView

KingDomino..> GameController : <<create>>
'KingDomino.> PlayerStrategy : <<use>>
'KingDomino..> GameMode : <<use>>
KingDomino ..>MyWindow : <<create>>
KingDomino ..>GameContext : <<create>>
MyWindow "1\n-controller" o-> GameController : > send \nuser request
MyWindow "1\n-game" o-> GameContext
GameContext "..n\n-observers" o-->GameObserver : > observes
GameView*->MyLabel : > label
ChoosingMenu*-->MyLabel : > label

Log .> GameContext : "notify"
@enduml