@startuml
'skinparam style strictuml
skinparam style strictuml
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods
skinparam BackgroundColor HoneyDew

'class main qui va executer le jeu
class KingDomino{
    +main()
}


package Controller{
'package CONTROLLER
package GameController #technology{
    ' plateau de jeu
    class GameController{
        -game: GameContext
        +GameController(game:GameContext)
        +initializeGame((nbPlayers:Integer,colors: KingColor[], gameMode:Integer)
        +placeCastle(player:Player, pos_x :Integer, pos_y :Integer
        +placeTile(player:Player, tile:Tile, x:Integer, y:Integer, dir:Direction)
        +skipTurn()
        +pickTiles()
        +chooseTile(tile:Tile)
        +rotate()
        +reverse()
        +destroyGame()
    }
}

}


package Model #mistyrose{
    'interface players
    interface PlayerStrategy <<Interface>>{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
    }
    class TwoPlayers implements PlayerStrategy{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
    }

    class ThreePlayers implements PlayerStrategy{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
    }

   class FourPlayers implements PlayerStrategy{
        + getNbBoard():Integer
        + getNbTile():Integer
        + getNbKings():Integer
   }


    class Deck{
        -tiles:Tile[]
        +Deck()
        +Deck(deckSize:Integer)
        +getTile():Tile
        +getNbTiles(): Integer
    }

    'tuiles numéroté
    class Tile {
        -number:Integer
        -left : Ground
        -right : Ground
        -direction:Direction
        +Tile(number: integer)
        +Tile(number: Integer, left:Ground, right : Ground)
        +getLeft():Ground
        +setLeft(left:Ground)
        +getRight():Ground
        +setRight(right: Ground)
        +getNumber():Integer
        +setNumber(number:Integer)
        +rotate()
        +reverse()
        +getDirection():Direction
        +compareTo(o: Tile): Integer

    }
    'coté de la tuile (droite ou gauche)
    class Ground implements Positionnable{
        -color: GroundColor
        -crownNumber:Integer
        -groundCounted:Boolean
        -crownCounted:Boolean
        +Ground(color:GroundColor, crownNumber:Integer)
        +isGroundCounted():Boolean
        +isCrownCounted():Boolean
        +setGroundCounted(groundCounted:Boolean)
        +setCrownCounted(crownCounted:Boolean)
        +getCrownNumber():Integer
        +getColor():GroundColor
        +setCrownNumber(crownNumber:Integer)
    }
    'couleur des cotés de la tuile
    enum GroundColor{
        -GREY
        -BLUE
        -DARKGREEN
        -BLACK
        -BROWN
        -YELLOW
        -LIGHTGREEN
        +{static}+getColor(String:color):GroundColor
    }
    'strategie permettant de pouvoir choisir le jeu qu'on veut
    interface GameMode <<Interface>>{
        +calculateScore(p:PlayerBoard)
        +getnamegame(): String
        +isHarmony(p:PlayerBoard):Boolean
        +isKingdomMiddle(p:PlayerBoard):Boolean
    }
    'contexte du jeu
    class GameContext{
        -nbPlayersStrat:PlayerStrategy
        -gameMode: GameMode
        -deck:Deck
        -currentTiles:Tile[]
        -observers : GameObserver[][]
        -players : Player[]
        -kings:King[]
        -nextRoundKings:King[]
        -turn : Integer

        +GameContext()
        +destroy()
        +getCurrentTiles(): King[]
        +addObserver(gameObserver:GameObserver)
        +setPlayerStrategy(nbPlayers:Integer)
        +getGameMode():GameMode
        +getNbPlayersStrat(): PlayerStrategy
        +setGameStrategy(gameModeChoosen: Integer)
        +initGame(colors: KingColor[],pseudo:String[])
        +getPlayers():Player[]
        +getPlayersNb():Integer

        -createDeck()
        -createKing(color:KingColor, number:Integer, player:Player)
        -createPlayers(colors:KingColor[],pseudo:String[])

        +getPlayerCastleTurn():Player
        +getKingTurn():King
        +getTurn(): Integer
        +pickTiles()
        +setCastle(player:Player, x: Integer, y: Integer): Boolean
        +setTile(x: Integer, y: Integer)
        +allTilesChoosen(): Boolean
        +chooseTile(tile:Tile)
        +orderNextRoundKings()
        +rotateCurrentTile()
        +reverseCurrentTile()
        +skipTurn()
        +getPlayersRank(Player[])
        +notifyObservers()
        +notifyObserversEnd()
    }

    package GameModes{

            class NormalMode {
                +calculateScore(p:PlayerBoard): Integer
                +countcell(p: PlayerBoard, x: Integer, y: Integer):Integer
                +coutcrown(p:PlayerBoard, x: Integer, y: Integer): Integer
                +getnamegame():String
                +isHarmony(p:PlayerBoard): Boolean
                +isKingdomMiddle(p:PlayerBoard):Boolean
            }
            abstract class ModeDecorator{
                -wrappee:GameMode
                +ModeDecorator(gameMode:GameMode)
                +calculateScore(p:Player):Integer
                +isKingdomMiddle(p:PlayerBoard):Boolean
                +isHarmony(p:PlayerBoard):Boolean
            }

            class MiddleKingdom extends ModeDecorator {
                +MiddleKingdom()
                +calculateScore(p:PlayerBoard):Integer
                -calculateKingdomBonus(p:PlayerBoard): Integer
                +isKingdomMiddle(p:PlayerBoard):Boolean
                +getnamegame():String
                +isHarmony(p:PlayerBoard):Boolean
            }

            'class harmonie
            class Harmony extends ModeDecorator {
            +Harmony()
            +calculateScore(p:PlayerBoard):Integer
            -calculateHarmonyBonus(p:PlayerBoard): Integer
            +isHarmony(p:PlayerBoard):Boolean
            +getnamegame():String
            +isKingdomMiddle(p:PlayerBoard):Boolean
            }
    }
    'interface observer qui va permettre de notifier les changements
    interface GameObserver <<Interface>>{
        +update(game:GameContext)
        +updateEnd(gameContext:GameContext)
    }

    class PlayerBoard{
        +BOARD_SIZE:Integer = 5
        -board: Positionnable[]
        +PlayerBoard(castle:Castle)
        +setCastle(x: Integer, y: Integer, castle: Castle) : Boolean
        +setTile(x:Integer, y:Integer, dir:Direction, tile:Tile): Boolean
        +getRightXY(x:Integer, y:Integer, dir:Direction): Integer[]
        +isPosable(x:Integer, y:Integer):Boolean
        +isPlayable(tile:Tile):Boolean
        +isSameGround(x:Integer, y:Integer, ground:Ground):Boolean
        +getPositionnable(x: Integer, y: Integer): Positionnable
        +getBoard():Positionnable[]
        +getBOARD_SIZE(): Integer
    }
    interface Positionnable <<Interface>>{
        +getColor():GroundColor
        +getCrownNumber(): Integer
        +isGroundCounted(): Boolean
        +isCrownCounted():Boolean
        +setGroundCounted(groundCounted:Boolean)
        +setCrownCounted(crownCounted:Boolean)
    }

    enum Direction{
        NORTH
        SOUTH
        EAST
        WEST
    }

    'joueur
    class Player{
        -playerColor: KingColor
        -board: PlayerBoard
        -playerName: String

        +Player(color:KingColor,board:PlayerBoard)
        +getPlayerColor(): KingColor
        +getPlayerName(): String
        +setPlayerColor(playerColor:KingColor)
        +getBoard(): PlayerBoard
        +setBoard(board:PlayerBoard)
    }

    'roi
    class King{
        -color: KingColor
        -player: Player
        -choosenTile:Tile[]
        +King(color:KingColor, player:Player)
        +getColor(): KingColor
        +setChoosenTile(tile:Tile)
        +removeTile()
        +getTile():Tile
        +getPlayer():Player
    }
    'class chateau
    class Castle implements Positionnable{
        +getColor():GroundColor
        +getCrownNumber(): Integer
        +isGroundCounted():Boolean
        +isCrownCounted():Boolean
        +setGroundCounted()
        +setCrownCounted()
    }

    'couleur du roi et du chateau
    enum KingColor{
    +PINK
    +BLUE
    +GREEN
    +YELLOW
    }


    }

'package VIEW
package view #D0E1D4{
    'application du jeu (design avec Swing)
    class MyWindow implements GameObserver{
        -gameController: GameController
        -game: GameContext
        -gameView: GameView

        +MyWindow(gameController: GameController, game: GameContext)
        +getGame(): GameContext
        +getGameController(): GameController
        +setGamePanel()
        +setChoosingMenu()
        +setMainMenu()
        +update(gameContext:GameContext)
        +updateEnd(gameContext:GameContext)
    }

    class MainMenu{
        -mainFrame: MyWindow
        -img: ImageIcon
        -btnColor : Color
        -btnHoverColor: Color

        +MainMenu(MyWindow: MyWindow)
        +paint(g: Graphics)
    }

    class ChoosingMenu{
         {static}shouldFill : Boolean
         -mainFrame : MyWindow
         -mainPnl:JPanel
         -group : ButtonGroup
         -nbPlayerChoice : String[]
         nbPlayerCbo : JComboBox

         -btnColor : Color
         -btnHoverColor: Color
         -cboColor: Color

         playerColorsPnl : JPanel

         - img: ImageIcon

         +ChoosingMenu(MyWindow: MyWindow)
         +getMainPanel():JPanel
         +paint(g: Graphics)
         -createColorCbo()
         -isDifferentColor():Boolean
        }

    class GameView{
        -mainFrame: MyWindow
        -img: ImageIcon
        -imgBoard : ImageIcon
        -boardsPanel: JPanel
        -gameInterac:JPanel
        -headerLbl: MyLabel
        -tourLbl : MyLabel
        -btnColor: Color
        -btnHoverColor: Color
        -errorMessageLbl: ErrorMessage
        -crownString: String

        +GameView(MyWindow:MyWindow)
        +getMainPanel():JPanel
        +createPlayerBoardPanel(player: Player, enable: Boolean): JPanel
        +createChoosenTile(tile: Tile, king: King)
        +createTile(tile: Tile, king : King): JPanel
        +createCastle(): JButton
        +updateInteractionBoard()
        +updatePlayersBoards()
        +update(game: GameContext)
        +paint(g: Graphics)
        }

    class EndView{
        -mainFrame : MyWindow
        -img : ImageIcon

        +EndView(MyWindow: MyWindow)
        +paint(g: Graphics)

    }
    class Log implements GameObserver{
        +update(gameContext:GameContext)
        +updateEnd(gameContext:GameContext)
    }


    package Components{
        class MyLabel{
        +MyLabel(text: String)
        +MyLabel(text: String, alignment: Integer)
        +setOutlineColor(c: Color)
        +setStroke(s: Stroke)
        +paintComponent(g:Graphics)
        }

        class ErrorMessage extends MyLabel{
             +ErrorMessage(view:JPanel)
             +setText(text:String)
        }
        class TileView extends JPanel{
            +TileView(gameController:GameController, tile:Tile, king:King,rotateMode:Boolean)
        }
        class PlayerBoardView extends JPanel{
            +PlayerBoardView(gameController:GameController, player:Player, game:GameContext, gameView:GameView
        }
    }
}

package Utilities{
        class CSVReader{
            {static} - RESSOURCE_PATH = "./kingdomino/ressources/"
            {static} read(filename:String):Collection<Collection<String>>
        }

        class IMGReader{
            {static}-TILE_IMG_SIZE:Integer = 60
            {static} - RESSOURCE_PATH = "./kingdomino/ressources/"
            {static} getImagePnl(String:filename):JLabel
            {static} getImage(String:filename):Image
            {static}+getTileImgSize()
        }
        class FontReader{
            {static} - instance : FontReader
            -algerian : Font
            -showcard : Font
            -bookmanold : Font
            -symbola : Font

            +getAlgerian(): Font
            +getShowcard(): Font
            +getBookmanold(): Font
            +getSymbola(): Font
        }
    }

'Implements Positionnable
'Ground ..|> Positionnable
'Castle ..|> Positionnable
PlayerBoard o-> "1\n -board"  Positionnable : > contains


Ground "1"*-->"1\n-color"GroundColor
Tile *--->"1-left \n 1-right" Ground :  > composed

'A SUPP
Deck  *-> "..* -tiles" Tile : > had


GameContext  o--> "..4\n-currentTiles" Tile
GameContext -> "1\n-deck"Deck
GameContext *--> "1\n-gameMode" GameMode  :  > select
GameContext *--> "1\n-playerStrategy" PlayerStrategy :  > select
GameContext *-> "2..4\n-players" Player :  > played by


'GameController est composé de GameContext => compositon
GameController *--> "1\n-gameContext" GameContext :  > had


Player *-> "1\n-board" PlayerBoard :  > had
Player  *->"1..2\n-playerKings" King :  > had


'Extends de ModeDecorator
ModeDecorator .u.|> GameMode
NormalMode .u.|> GameMode

ModeDecorator o-->"1\n-mode" GameMode

King"1"*-> "1\n-color" KingColor: > had
Castle*->"1\n-color"GroundColor : > had

MyWindow  *--> "1\n-gameView" GameView : > display
MyWindow  *-> "1\n-mainMenu" MainMenu : > display
MyWindow  *-> "1\n-choosingMenu" ChoosingMenu : > display
MyWindow  *--> "1\n-endView" EndView : > display

MyWindow o-> "1\n-controller" GameController : > send \nuser request
MyWindow  o-> "1\n-game"GameContext
GameContext o-->"..n\n-observers" GameObserver : > observes
GameView *-->MyLabel : > label
EndView *->MyLabel : > label
ChoosingMenu *-> "*" MyLabel : > label

Log .> GameContext : "notify"

'les liaisons use et create
KingDomino..> GameController : <<create>>
KingDomino .>MyWindow : <<create>>
KingDomino .>GameContext : <<create>>

PlayerBoard ..> Direction : <<use>>

Deck .> CSVReader :  <<use>>

EndView ..> IMGReader : <<use>>
GameView ..> IMGReader: <<use>>
ChoosingMenu ..> IMGReader : <<use>>
MainMenu .> IMGReader : <<use>>

EndView ...>FontReader :<<use>>
GameView ...>FontReader :<<use>>
ChoosingMenu ..>FontReader :<<use>>
MainMenu .>FontReader :<<use>>

GameView .>TileView : <<use>>
GameView ..>PlayerBoardView : <<use>>

@enduml